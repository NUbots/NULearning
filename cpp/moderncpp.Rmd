---
title: Modern C++
author: "Cameron Murtagh"
date: "27/7/2021"
output:
    md_document:
        variant: gfm
---

```{r setup, include=FALSE}
library(knitr)
library(tools)
library(stringi)

unlink(".tmp_c", recursive=TRUE)

knitr::knit_engines$set(cpp = function(options){
    code = paste(options$code, collapse = '\n')
    #opts = options$engine.opts # TODO

    unnamed = grepl("unnamed-chunk-", options$label)
    file_name = options$label
    if(unnamed){
        file_name = paste(c(stri_rand_strings(1,5), "cpp"), collapse='.')
    }

    directory = file.path(getwd(), ".tmp_c")

    if(!dir.exists(directory)){
        dir.create(directory)
    }

    source_path = file.path(directory, file_name)

    message("Saving file to ", source_path)
    write(code, file=source_path)

    exec_output = ""
    
    if (options$eval && file_ext(source_path) != "hpp"){
        executable_path = file_path_sans_ext(source_path)
        # TODO custom compiler
        compile_output = system2("clang++", c("-Wall", "-g", "-o", executable_path, source_path), stdout=TRUE, stderr=TRUE)
        # Check for successful compile
        if(length(compile_output) == 0){
            Sys.chmod(executable_path)
            exec_output = system2(executable_path, stdout=TRUE, stderr=TRUE)
        }else{
            exec_output = compile_output
        }
    }
    knitr::engine_output(options, code, paste(exec_output, collapse='\n'))
})
```

```{cpp A.hpp, include=FALSE}
// A cheeky file that we can include later
#include <iostream>
struct A{
    int* x;
    A() : x(nullptr) {}
    A(const int& _x) : x(new int(_x)) {
        std::cout << "constructing A pointing to " << x << std::endl;
    }
    ~A() {
        std::cout << "destructing A, which pointed to " << x << std::endl;
        if (x != nullptr) {
            delete x;
            x = nullptr;
        }
    }
    A(const A& other) {
        std::cout << "copy construction, old " << x
        << " other's " << other.x;
        x = new int(*other.x);
        std::cout << " new " << x << std::endl;
    }
    A(A&& other) {
        std::cout << "move construction, old " << x
        << " other's " << other.x;
        x = other.x;
        if (other.x != nullptr) {
            other.x = nullptr;
        }
        std::cout << " new " << x << std::endl;
    }
    A& operator=(const A& other) {
        std::cout << "copy assignment, old " << x
        << " other's " << other.x;
        int* _x = x; // stop allocation in the recently deleted spot
        x = new int(*other.x);
        if(x != nullptr) {
            delete _x;
        }
        std::cout << " new " << x << std::endl;
        return *this;
    }
    A& operator=(A&& other) {
        std::cout << "move assignment, old " << x
        << " other's " << other.x;
        if(x != nullptr) {
            delete x;
            x = nullptr;
        }
        x = other.x;
        if (other.x != nullptr) {
            other.x = nullptr;
        }
        std::cout << " new " << x << std::endl;
        return *this;
    }
};
```

# Struct

`class` has all its members private by default. 
In c++ a `struct` is a `class` that has all its members public by default.

# Const

Const declares a type immutable, that is that the value is read only and cannot be mutated.

## Variables

To declare a variable `const` simply add the keyword to the type.

```{cpp}
#include <iostream>
int main(){
    const int x = 1;
    const int& y = x;
    std::cout << "x = " << x << ", y = " << y << std::endl;
}
```

```{cpp}
int main(){
    const int x = 1;
    x ++;
}
```

## Parameters

This is usually used with pass by reference, but can be used with pass by value even though that would usually be pointless.
Having a pass by reference parameter declared as constant allows the caller to be sure that the parameter they pass in will not be changed.

```{cpp}
#include <iostream>
void cool_print(const int& x, const int& y){
    std::cout << "x " << x << " y " << y << std::endl;
}

void definitly_benign_print(const int& x, int& y){
    std::cout << "x " << x << " y " << y++ << std::endl;
}

int main(){
    const int a = 7;
    int b = 5;
    cool_print(a, b);
    definitly_benign_print(a, b);
    cool_print(a, b);
}
```


## Methods

To add const to a method add the keyword to the end of the signature. This means that the method cannot mutate any of the attributes.

If there is an instance of a type declared const it cannot call any method that is not declared const.

```{cpp}
#include <iostream>
struct T {
    int x = 1;
    
    int get_x() const {
        return x;
    }
    
    void set_x(const int& x_) {
        x = x_;
    }
};

int main(){
    T a;
    a.set_x(5);
    std::cout << "a " << a.get_x() << std::endl;
    
    const T b;
    b.set_x(5);
    std::cout << "b " << b.get_x() << std::endl;
}
```

## Const Type

The `const` version is actually a distinct type to the original type but `c++` can implicitly cast to a `const` type from the non-const type.
e.g. `std::array<const int, 1>` and `std::array<int, 1>` are distinct types, this can be observed by using the subscript operator as it will return `const int&` and `int&` respectively.

``` {cpp}
template <typename T>
struct simple_container {
    T x;
};

int main(){
    const simple_container<int> x = {1};
    simple_container<int> y = {2};
    y = x;
    simple_container<const int> z = {3};
    z = y;
}
```

In this example we cannot convert from `simple_container<int>` to `simple_container<const int>` as they are different types, and thus need an explicit conversion defined.

## Raw Pointers

There are some caveats with raw pointers, but we don't use raw pointers, so if that ever is the case there are many other resources explaining what is happening.

## Task

a. Add const to the following variables that don't change.

``` cpp
#include <iostream>
int main(){
    int x = 2;
    int y = 7;

    int accumilate = 0;
    for (int i = 0; i < y; i++){
        accumilate += x;
    }
    std::cout << accumilate << std::endl;
}
```

b. Add const to the following methods that don't mutate the attributes.

``` cpp
struct square {
    int x;
    int y;
    int width;
    int height;

    int get_x() {
        reuturn x;
    }

    int get_y() {
        return y;
    }

    int area() {
        return width * height;
    }

    int double_area() {
        width *= 1.4142;
        height *= 1.4142;
        return area();
    }
}
```

# Auto Keyword

The compiler infers the type at compile time.

```{cpp}
#include <iostream>
int main() {
    auto x = 5;
    int y = x;
    std::cout << "x = " << x << ", y = " << y << std::endl;
}
```

The `auto` keyword can also be used to define references and "raw" pointers, using `auto&` and `auto*`. The `const` keyword also applies as you would expect to `auto` declarations.

Some C++ people think you should "almost always [use] auto", but we don't. Our most common use of `auto` is for the iterator's object in a range-based `for` loop, as in the following example:

```{cpp}
#include <iostream>
#include <array>
#include <string>
int main(){
    std::array<std::string, 5> letters {"a", "b", "c", "d", "e"};

    // Range-based for loops automatically create iterators for containers
    // which support them, such as std::array, and dereference them for us. 
    // You should usually use `const auto&`, `auto&` (or `auto&&`) for these 
    // variables, because they're huge, ugly, std::iterator types which are 
    // hard to read
    for (const auto& letter : letters) {
        std::cout << letter << std::endl;
    }
}
```

### DO NOT USE `auto` FOR EIGEN TYPES

Eigen's docs list using the `auto` keyword for their types as a [common pitfall](https://eigen.tuxfamily.org/dox/TopicPitfalls.html). This is mostly because Eigen uses intermediate types all the time with many implicit conversions, which are not at all obvious to the reader.

### Task

a. Write a program which uses `auto` to define a string, then use auto to define a custom class or struct type `T`.


b. Add a range-based for loop to the program, iterating through an array of your class type.

``` cpp
#include <array>
#include <string>
#include <iostream>
struct T {
    int x;
    T (cons int& x_) : x(x_) {}
}

int main() {
    // Define a your string here, call it str
    
    // Define an instance of type T here, call it t

    std::cout << "str: " << str << ", t.x:" << t.x << std::endl;

    std::array<T, 3> a = {T(1), T(2), T(3)};

    // Add the start of your for loop here
    {
        std::cout << i.x << std::endl;
    }
}

```

# Initializer Lists & Namespaces

Initializer lists can be used in constructors to initialise values for member variables, even if they're const. Here is an example of the syntax:

``` cpp
#include "kev/FooLongName.hpp"

namespace bar::baz {
```

This scope defines a namespace `baz` inside of the namespace `bar`.

``` cpp
    using Foo = kev::FooLongName;
```

This is a type alias. These serve the same function as `typedef` statements, except they don't declare a new type like `typedef`s do. These can make things more concise but we don't use them often, for the sake of clarity over conciseness.

``` cpp
    using kev::FooLongName::getAlternativeConfig;
```

Adds this name into this namespace. We do use these often, to import function names, so we don't have huge, long function names within four nested namespaces

``` cpp
    class A {
        const int a = 0; // Can still be given another value by a constructor, by using
                         // an initializer list, despite being `const`

        Foo thing_f{};   // Brace-initialisation - calls the associated constructor in-place

        A() = default;   // Makes the compiler define the default constructor for us
                         // even though we defined another constructor, which otherwise
                         // would make the compiler delete the default one
                        
        A(const int& a_) : a(a_), thing_f(getAlternativeConfig()) // We can even call functions in
                                                                  // initializer lists, such as
                                                                  // this previously `using`'d one
        {
            // This code is executed after the initializer list is finished doing things
        }
    };
} // namespace bar::baz
```

(Note that if a member variable or object has no default constructor, it must be initialised using an initializer list.)

This example makes liberal use of _namespaces_. Namespaces let us separate functions and objects into different spots where their symbols won't conflict. For example, we can have a function in the `bar::baz` namespace called `run()` with the same signature (besides the namespace) as `foo::run()`, or even `bar::run()`.

**Anonymous namespaces** are namespaces which don't have names. These restrict use of the things inside of the namespace to the things inside the same file as the things in the anonymous namespace. Anonymous namespaces [should not be used in headers](https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL59-CPP.+Do+not+define+an+unnamed+namespace+in+a+header+file#:~:text=Do%20not%20define%20an%20unnamed%20namespace%20in%20a%20header%20file&text=When%20an%20unnamed%20namespace%20is,used%20within%20that%20translation%20unit.). Here is an example using an anonymous namespace:

``` cpp
#include "foo.hpp"

// Anonymous namespace - keeps these things accessible only within this file
namespace {
    return_type helper_function() { 
        // does things
    }
}

baz_type foo::baz() {
    // We can call `helper_function` in this file, but we can't call it outside of this file.
    // This keeps it local to this file, without any chance of it being used by anything else.
    const auto bar = helper_function();
    return f(bar);
}
```

# Object Ownership

The model for resource management, e.g. heap memory, we use is called object ownership. This is where each object has something, usually another object, that is responsible for freeing the resource.

## Basic Functions

Firstly we'll create an object that owns some heap memory and will print out all the common functions that deal with ownership.

### Attributes

``` cpp
struct A {
    int* x; // Usually you shouldn't use "raw" pointers like this
            // this is just for illustrative purposes
};
```

### Constructor and Destructor

We'll create the constructor and destructor similar as to what you would have done in **SENG1120**.

``` cpp
// Default Constructor
A() : x(nullptr) {}

// Constructor
A(const int& _x) : x(new int(_x)) {
    std::cout << "constructing A pointing to " << x << std::endl;
}

// Destructor
~A() {
    std::cout << "destructing A, which pointed to " << x << std::endl;
    if (x != nullptr) {
        delete x;
        x = nullptr;
    }
}
```
```{cpp}
#include "A.hpp"
int main() {
    A a{1};
}
```

### Copy Constructor

For copy construction we will create a deep copy of the object. This means that we will follow any pointers and copy the objects they point to. We do this because there are no guarantees that the objects pointed to will not be deconstructed by something else.

We do not gain any ownership over anything relating to the parameter but we do now own the newly constructed integer.

``` cpp
// Copy constructor
A(const A& other) {
    std::cout << "copy constructor, old " << x
    << " other's " << other.x;
    x = new int(*other.x);
    std::cout << " new " << x << std::endl;
}
```
```{cpp}
#include "A.hpp"
int main(){
    A a{1};
    A b{a};
}
```


### Copy Assignment

Similar to copy construction, but if this object has ownership of something we must first clean that up.

``` cpp
// Copy assignment
A& operator=(const A& other) {
    std::cout << "copy assignment, old " << x
    << " other's " << other.x;
    if(x != nullptr) {
        delete x;
        x = nullptr;
    }
    x = new int(*other.x);
    std::cout << " new " << x << std::endl;
    return *this;
}
```
```{cpp}
#include "A.hpp"
int main() {
    A a{1};
    A b{2};
    b = a;
}
```

### Move Constructor

For a move constructor the parameter that is passed has had its ownership yielded, so we can be sure that nothing else will use or free the passed in resources. This allows us to do a shallow copy of the pointed to values, this means that we can just copy the pointers.

``` cpp
// Move constructor
A(A&& other) {
    std::cout << "move constructor, old " << x
    << " other's " << other.x;
    x = other.x;
    if (other.x != nullptr){
        other.x = nullptr;
    }
    std::cout << " new " << x << std::endl;
}
```
```{cpp}
#include <utility>
#include "A.hpp"
int main() {
    A a{1};
    A b(std::move(a));
}
```


### Move Assignment

Similar to move construction, but if this object has ownership of something we must first clean that up.

``` cpp
// Move assignment
A& operator=(A&& other) {
    std::cout << "move assignment, old " << x
    << " other's " << other.x;
    if(x != nullptr){
        delete x;
        x = nullptr;
    }
    x = other.x;
    if (other.x != nullptr){
        other.x = nullptr;
    }
    std::cout << " new " << x << std::endl;
    return *this;
}
```
```{cpp}
#include <utility>
#include "A.hpp"
int main() {
    A a{1};
    A b{};
    b = std::move(a);
}
```

### Task

Create a struct which has the following:

1. A default constructor which prints the string "Default constructor called"
2. A copy constructor which prints the string "Copy constructor called"
3. A copy operator which prints the string "Copy operator called"
4. A move constructor which prints the string "Move constructor called"
5. A move operator which prints the string "Move operator called"

Once you have defined these, write a program which uses each of them, printing all 5 strings.

``` cpp
struct ownership_class{
    // Make an attribute here

    // Make a default constructor here
    
    // Make a copy constructor here

    // Make a move constructor here

    // Make a copy assignment operator here

    // Make a move assignment operator here
    
};

ownership_class test_function() {
    return ownership_class();
}

int main() {
    ownership_class a; // Default construct
    ownership_class b{a}; // Copy construct
    ownership_class c{test_function()}; // Move construct
    ownership_class d = a; // Copy assignment
    ownership_class c = test_function(); // Move assignment
}
```

#### Post task notes

The copy and move constructors/operators along with the destructor, are known as the special member functions. They are automatically defined for all classes and structs, unless you provide a definition for them yourself. 

The **Rule of 5** says that if you define a non-default destructor, you should define all 5 special member functions explicitly or delete them. The following example implements a non-default destructor to handle a class's file descriptor, abiding by the rule of 5:

``` cpp
A() : fd(-1); // Default file descriptor value
~A() {
    close(fd); // Close the file descriptor on destruction, which is quite typical
}
// Delete our other special member functions, so we don't have to deal with
// transferral of the file descriptor to other `A` instances
A(A& other) = delete;
A(A&& other) = delete;
A& operator=(A& other) = delete;
A& operator=(A&& other) = delete;
```

## r and l values

A l-value is a reference that references a value bound to a variable. In the function this is a single ampersand `&`.

A r-value is a reference that is not bound to a variable. r-values are temporary and thus the ownership of the value is yielded to the function it is passed to. In the function this is a double ampersand `&&`.

A l-value can be converted to an r-value by using `std::move`. r-values are returned from functions that return by value.

Move semantics use r-value and copy semantics use l-value.

```{cpp}
#include "A.hpp"
A cool() {
    return A(5);
}
int main() {
    A x = cool();
}
```

## Smart Pointers

To manage memory and ownership we use smart pointers. Smart pointers handle deletion of our objects for us with some caveats. A smart pointer owns the object that it points to.

### Raw Pointers

A raw pointer is a pointer with no wrapping object, this is exactly what you would have used in **SENG1120**. You should use smart pointers over raw pointers whenever possible, which is when you have ownership of the memory, which is _almost_ always. The one common counterexample we run into is pointers to objects the webots API provides us. We can't call delete on these, because webots is in charge of managing them, so should not use smart pointers with them.

### Unique

A unique pointer is a smart pointer that will manage an object on the heap, deleting it when the pointer goes out of scope.

Always use `std::make_unique` as this solves some problems. Never use `new`.

```{cpp}
#include <memory>
#include "A.hpp"
int main() {
    std::unique_ptr<A> a = std::make_unique<A>(5);
    {
    // Make a scope so we can see this object get deleted before the one below gets constructed.
    std::unique_ptr<A> b = std::make_unique<A>(5);
    }
    std::unique_ptr<A> c = std::make_unique<A>(5);
}
```
We cannot copy a unique pointer, we can only move it. This prevents two separate objects owning the object that is pointed to.

```{cpp}
#include <memory>
#include "A.hpp"
int main() {
    std::unique_ptr<A> a = std::make_unique<A>(5);
    std::unique_ptr<A> b = a;
}
```
```{cpp}
#include <memory>
#include <utility>
#include "A.hpp"
int main() {
    std::unique_ptr<A> a = std::make_unique<A>(5);
    std::unique_ptr<A> b = std::move(a);
}
```

#### Exception Memory Safety

Smart pointers are safer when dealing with exceptions. Here the smart pointer is deleted whilst the raw pointer is leaked.

```{cpp}
#include <memory>
#include "A.hpp"
int main() {
    try {
        auto* a = new A(1);
        auto b = std::make_unique<A>(1);
        // if (error occurs) {
            throw std::runtime_error("Oh no!");
        // }
        delete a;
    } catch (...) {}
}
```

#### Loaning

If another object needs to temporarily have access to an object, you pass a reference to the pointed to object as a parameter. The object that gains temporary access and should assume that the object is freed after the function has returned.

``` cpp
#include <memory>
#include <iostream>
void borrow_function(const int& x) {
    std::cout << x << std::endl;
}
int main() {
    auto a = std::make_unique<int>();
    borrow_function(*a);
}
```

Webots uses raw pointers to loan objects to us, which is why we do not use smart pointers with webots code.

### Shared

A shared pointer allows for multiple objects to have access to the pointer. This is done by keeping a count of the number of shared pointers that point to an object with the object. When this count reaches zero both the counter and the object are deleted.

Use of shared ownership is rare and always prefer unique pointers where you can.

```{cpp}
#include <memory>
#include "A.hpp"
int main(){
    auto a = std::make_shared<A>(1);
    auto b = a;
}
```

### Weak

A weak pointer points to an object that is pointed to by a shared pointer, but does not count towards the total count. When accessing the object pointed to the weak pointer is temporarily upgraded to a shared pointer. The main use of weak pointers is to get rid of circular references for shared pointers, often found in loops.

```{cpp}
#include <memory>
#include <iostream>
struct node_bad {
    std::shared_ptr<node_bad> other;
    node_bad(const std::shared_ptr<node_bad>& other_ = std::shared_ptr<node_bad>()) : other(other_) {
        std::cout << "Constructor " << this << std::endl;
    }
    ~node_bad() {
        std::cout << "Destructor " << this  << std::endl;
    }
};
struct node_good {
    std::weak_ptr<node_good> other;
    node_good(const std::weak_ptr<node_good>& other_ = std::weak_ptr<node_good>()) : other(other_) {
        std::cout << "Constructor " << this << std::endl;
    }
    ~node_good() {
        std::cout << "Destructor " << this  << std::endl;
    }
};
int main() {
    auto a = std::make_shared<node_bad>();
    auto b = std::make_shared<node_bad>(a);
    a->other = b;

    auto c = std::make_shared<node_good>();
    auto d = std::make_shared<node_good>(c);
    c->other = d;
}
```

### Deleter

For some legacy or c functions, there may be a custom delete function for that type.

```{cpp}
#include <memory>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
int main() {
    addrinfo hints;
    addrinfo* info;
    getaddrinfo("127.0.0.1", "80", &hints, &info);
    auto a = std::unique_ptr<addrinfo, decltype(&freeaddrinfo)>(info, freeaddrinfo);
}
```

### Task

a. Store an integer in a unique pointer using `make_unique`


``` cpp
#include <memory>

int main(){
    // Put unique pointer here
}
```


# Standard Library Features

## Array

A `std::array` is similar to a c-style array but you specify the size of the array at compile-time. [Reference Page](https://en.cppreference.com/w/cpp/container/array).

## Vector

This is an array where we pass the size of the array at run-time, we can also resize the vector by adding elements. [Reference Page](https://en.cppreference.com/w/cpp/container/vector).

It has both a size and a capacity, size is the number of current elements and capacity is the current size of the underlying c array. When the size reaches capacity, c++ will allocate more memory and increase the capacity. Make sure that you try to reduce the number of time that the capacity is changed, one way to do this is to reserve space when you plan to add more than one element.

Removing and adding elements near the start of the vector is slow, see [Reference Page](https://en.cppreference.com/w/cpp/container/vector) for time complexities, use a deque when you plan to do this often.

If you have done java, this is similar to `ArrayList`.

## Deque

A `std::deque` implements a deque. The expansion of capacity and insertion or removal of elements at the ends is much faster than a vector, but takes up more memory and access is slower. Usually a vector is better as we usually do more reads than insertion and removals.

## Map

This is an associative data structure, it associates values to keys. It can either be a red-black tree, [std::map](https://en.cppreference.com/w/cpp/container/map), or a hash map, [std::unordered_map](https://en.cppreference.com/w/cpp/container/unordered_map).

