---
title: Modern C++
autor: "Cameron Murtagh"
date: "27/7/2021"
output:
    md_document:
        variant: markdown_github+backtick_code_blocks
---

```{r setup, include=FALSE}
library(knitr)
library(tools)
library(stringi)

unlink(".tmp_c", recursive=TRUE)

knitr::knit_engines$set(cpp = function(options){
    code = paste(options$code, collapse = '\n')
    #opts = options$engine.opts # TODO

    unnamed = grepl("unnamed-chunk-", options$label)
    file_name = options$label
    if(unnamed){
        file_name = paste(c(stri_rand_strings(1,5), "cpp"), collapse='.')
    }

    directory = file.path(getwd(), ".tmp_c")

    if(!dir.exists(directory)){
        dir.create(directory)
    }

    source_path = file.path(directory, file_name)

    message("Saving file to ", source_path)
    write(code, file=source_path)

    exec_output = ""
    
    if (options$eval && file_ext(source_path) != "hpp"){
        executable_path = gsub(file_ext(source_path), "out", source_path)
        # TODO custom compiler
        compile_output = system2("clang++", c("-Wall", "-g", "-o", executable_path, source_path), stdout=TRUE, stderr=TRUE)
        # Check for successful compile
        if(length(compile_output) == 0){
            Sys.chmod(executable_path)
            exec_output = system2(executable_path, stdout=TRUE, stderr=TRUE)
        }else{
            exec_output = compile_output
        }
    }
    knitr::engine_output(options, code, paste(exec_output, collapse='\n'))
})
```

```{cpp A.hpp, include=FALSE}
// A cheeky file that we can include later
#include <iostream>
struct A{
    int* x;
    A() : x(nullptr) {}
    A(const int& _x) : x(new int(_x)) {
        std::cout << "constructing A pointing to " << x << std::endl;
    }
    ~A() {
        std::cout << "destructing A, which pointed to " << x << std::endl;
        if (x != nullptr) {
            delete x;
            x = nullptr;
        }
    }
    A(const A& other) {
        std::cout << "copy construction, old " << x
        << " other's " << other.x;
        x = new int(*other.x);
        std::cout << " new " << x << std::endl;
    }
    A(A&& other) {
        std::cout << "move construction, old " << x
        << " other's " << other.x;
        x = other.x;
        if (other.x != nullptr) {
            other.x = nullptr;
        }
        std::cout << " new " << x << std::endl;
    }
    A& operator=(const A& other) {
        std::cout << "copy assignment, old " << x
        << " other's " << other.x;
        int* _x = x; // stop allocation in the recently deleted spot
        x = new int(*other.x);
        if(x != nullptr) {
            delete _x;
        }
        std::cout << " new " << x << std::endl;
        return *this;
    }
    A& operator=(A&& other) {
        std::cout << "move assignment, old " << x
        << " other's " << other.x;
        if(x != nullptr) {
            delete x;
            x = nullptr;
        }
        x = other.x;
        if (other.x != nullptr) {
            other.x = nullptr;
        }
        std::cout << " new " << x << std::endl;
        return *this;
    }
};
```
# Auto Keyword

The compiler infers the type at compile time.

```{cpp}
#include <iostream>
int main() {
    auto x = 5;
    int y = x;
    std::cout << "x = " << x << ", y = " << y << std::endl;
}
```

The `auto` keyword can also be used to define references and "raw" pointers, using `auto&` and `auto*`. The `const` keyword also applies as you would expect to `auto` declarations.

Some C++ people think you should "almost always [use] auto", but we don't. Our most common use of `auto` is for the iterator's object in a range-based `for` loop, as in the following example:

```{cpp}
#include <iostream>
#include <array>
#include <string>

std::array<5, std::string> letters {"a", "b", "c", "d", "e"};

// Range-based for loops automatically create iterators for containers
// which support them, such as std::array, and dereference them for us. 
// You should usually use `const auto&`, `auto&` (or `auto&&`) for these 
// variables, because they're huge, ugly, std::iterator types which are 
// hard to read
for (const auto& letter : letters) {
    std::cout << letter << std::endl;
}
```

### DO NOT USE `auto` FOR EIGEN TYPES

Eigen's docs list using the `auto` keyword for their types as a [common pitfall](https://eigen.tuxfamily.org/dox/TopicPitfalls.html). This is mostly because Eigen uses intermediate types all the time with many implicit conversions, which are not at all obvious to the reader.

### Task

a. Write a program which uses `auto` to define a string, then use auto to define a custom class or struct type `T`.
b. Add a range-based for loop to the program, iterating through a `std::vector<T>` of your class type. `std::vector` is a dynamically sized array, which is very similar to Java's `ArrayList`. It's very good and very fast - we use it all the time when we have to use the heap (we stick to using the stack whenever possible though). Use `emplace_back` to construct the `T` instances as you add them to the `std::vector`.

# Object Ownership

The model for resource management, e.g. heap memory, we use is called object ownership. This is where each object has something, usually another object, that is responsible for freeing the resource.

## Basic Functions

Firstly we'll create an object that owns some heap memory and will print out all the common functions that deal with ownership.

### Attributes

```{cpp, eval=FALSE}
struct A {
    int* x; // Usually you shouldn't use "raw" pointers like this
            // this is just for illustrative purposes
};
```

### Constructor and Destructor

We'll create the constructor and destructor similar as to what you would have done in **SENG1120**.

```{cpp, eval=FALSE}
// Default Constructor
A() : x(nullptr) {}

// Constructor
A(const int& _x) : x(new int(_x)) {
    std::cout << "constructing A pointing to " << x << std::endl;
}

// Destructor
~A() {
    std::cout << "destructing A, which pointed to " << x << std::endl;
    if (x != nullptr) {
        delete x;
        x = nullptr;
    }
}
```
```{cpp}
#include "A.hpp"
int main() {
    A a{1};
}
```

### Copy Constructor

For copy construction we will create a deep copy of the object. This means that we will follow any pointers and copy the objects they point to. We do this because there are no guarantees that the objects pointed to will not be deconstructed by something else.

We do not gain any ownership over anything relating to the parameter but we do now own the newly constructed integer.

```{cpp, eval=FALSE}
// Copy constructor
A(const A& other) {
    std::cout << "copy constructor, old " << x
    << " other's " << other.x;
    x = new int(*other.x);
    std::cout << " new " << x << std::endl;
}
```
```{cpp}
#include "A.hpp"
int main(){
    A a{1};
    A b{a};
}
```


### Copy Assignment

Similar to copy construction, but if this object has ownership of something we must first clean that up.

```{cpp, eval=FALSE}
// Copy assignment
A& operator=(const A& other) {
    std::cout << "copy assignment, old " << x
    << " other's " << other.x;
    if(x != nullptr) {
        delete x;
        x = nullptr;
    }
    x = new int(*other.x);
    std::cout << " new " << x << std::endl;
    return *this;
}
```
```{cpp}
#include "A.hpp"
int main() {
    A a{1};
    A b{2};
    b = a;
}
```

### Move Constructor

For a move constructor the parameter that is passed has had its ownership yielded, so we can be sure that nothing else will use or free the passed in resources. This allows us to do a shallow copy of the pointed to values, this means that we can just copy the pointers.

```{cpp, eval=FALSE}
// Move constructor
A(A&& other) {
    std::cout << "move constructor, old " << x
    << " other's " << other.x;
    x = other.x;
    if (other.x != nullptr){
        other.x = nullptr;
    }
    std::cout << " new " << x << std::endl;
}
```
```{cpp}
#include <utility>
#include "A.hpp"
int main() {
    A a{1};
    A b(std::move(a));
}
```


### Move Assignment

Similar to move construction, but if this object has ownership of something we must first clean that up.

```{cpp, eval=FALSE}
// Move assignment
A& operator=(A&& other) {
    std::cout << "move assignment, old " << x
    << " other's " << other.x;
    if(x != nullptr){
        delete x;
        x = nullptr;
    }
    x = other.x;
    if (other.x != nullptr){
        other.x = nullptr;
    }
    std::cout << " new " << x << std::endl;
    return *this;
}
```
```{cpp}
#include <utility>
#include "A.hpp"
int main() {
    A a{1};
    A b{};
    b = std::move(a);
}
```

### Task

Create a struct which has the following:

1. A default constructor which prints the string "Default constructor called"
2. A copy constructor which prints the string "Copy constructor called"
3. A copy operator which prints the string "Copy operator called"
4. A move constructor which prints the string "Move constructor called"
5. A move operator which prints the string "Move operator called"

Once you have defined these, write a program which uses each of them, printing all 5 strings.

#### Post task notes

The copy and move constructors/operators along with the destructor, are known as the special member functions. They are automatically defined for all classes and structs, unless you provide a definition for them yourself. 

The **Rule of 5** says that if you define a non-default destructor, you should define all 5 special member functions explicitly or delete them. The following example implements a non-default destructor to handle a class's file descriptor, abiding by the rule of 5:

```{cpp, eval=FALSE}
A() : fd(-1); // Default file descriptor value
~A() {
    close(fd); // Close the file descriptor on destruction, which is quite typical
}
// Delete our other special member functions, so we don't have to deal with
// transferral of the file descriptor to other `A` instances
A(A& other) = delete;
A(A&& other) = delete;
A& operator=(A& other) = delete;
A& operator=(A&& other) = delete;
```

## Smart Pointers

To manage memory and ownership we use smart pointers. Smart pointers handle deletion of our objects for us with some caveats. You should use smart pointers over "raw" pointers whenever possible, which is when you have ownership of the memory, which is _almost_ always. The one common counterexample we run into is pointers to objects the webots API provides us. We can't call delete on these, because webots is in charge of managing them, so should not use smart pointers with them.

### Unique

A unique pointer will manage an object on the heap, deleting it when the pointer goes out of scope.

Always use `std::make_unique` as this solves some problems. Never use `new`.

```{cpp}
#include <memory>
#include "A.hpp"
int main(){
    std::unique_ptr<A> a = std::make_unique<A>(5);
    {
    // Make a scope so we can see this object get deleted before the one below gets constructed.
    std::unique_ptr<A> b = std::make_unique<A>(5);
    }
    std::unique_ptr<A> c = std::make_unique<A>(5);
}
```
We cannot copy a unique pointer, we can only move it. This prevents two separate objects owning the object that is pointed to.

```{cpp}
#include <memory>
#include "A.hpp"
int main(){
    std::unique_ptr<A> a = std::make_unique<A>(5);
    std::unique_ptr<A> b = a;
}
```
```{cpp}
#include <memory>
#include <utility>
#include "A.hpp"
int main(){
    std::unique_ptr<A> a = std::make_unique<A>(5);
    std::unique_ptr<A> b = std::move(a);
}
```

### Shared

### Weak

# Standard Library Features

# C++ Feautres
