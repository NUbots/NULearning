---
title: Modern C++
autor: "Cameron Murtagh"
date: "27/7/2021"
output: pdf_document
---

```{r setup, include=FALSE}
library(knitr)
library(tools)
library(stringi)

unlink(".tmp_c", recursive=TRUE)

knitr::knit_engines$set(cpp = function(options){
    code = paste(options$code, collapse = '\n')
    #opts = options$engine.opts # TODO

    unnamed = grepl("unnamed-chunk-", options$label)
    file_name = options$label
    if(unnamed){
        file_name = paste(c(stri_rand_strings(1,5), "cpp"), collapse='.')
    }

    directory = file.path(getwd(), ".tmp_c")

    if(!dir.exists(directory)){
        dir.create(directory)
    }

    source_path = file.path(directory, file_name)

    message("Saving file to ", source_path)
    write(code, file=source_path)

    exec_output = ""
    
    if (options$eval && file_ext(source_path) != "hpp"){
        executable_path = gsub(file_ext(source_path), "out", source_path)
        # TODO custom compiler
        compile_output = system2("clang++", c("-Wall", "-g", "-o", executable_path, source_path), stdout=TRUE, stderr=TRUE)
        # Check for successful compile
        if(length(compile_output) == 0){
            Sys.chmod(executable_path)
            exec_output = system2(executable_path, stdout=TRUE, stderr=TRUE)
        }else{
            exec_output = compile_output
        }
    }
    knitr::engine_output(options, code, paste(exec_output, collapse='\n'))
})
```

```{cpp A.hpp, include=FALSE}
// A cheeky file that we can include later
#include <iostream>
struct A{
    int* x;
    A():x(nullptr){}
    A(const int& _x) : x(new int(_x)){
        std::cout << "constructing A pointing to " << x << std::endl;
    }
    ~A(){
        std::cout << "destructing A, which pointed to " << x << std::endl;
        if (x != nullptr){
            delete x;
            x = nullptr;
        }
    }
    A(const A& other){
        std::cout << "copy construction, old " << x
        << " other's " << other.x;
        x = new int(*other.x);
        std::cout << " new " << x << std::endl;
    }
    A(A&& other){
        std::cout << "move construction, old " << x
        << " other's " << other.x;
        x = other.x;
        if (other.x != nullptr){
            other.x = nullptr;
        }
        std::cout << " new " << x << std::endl;
    }
    A& operator=(const A& other){
        std::cout << "copy assignment, old " << x
        << " other's " << other.x;
        int* _x = x; // stop allocation in the recently deleted spot
        x = new int(*other.x);
        if(x != nullptr){
            delete _x;
        }
        std::cout << " new " << x << std::endl;
        return *this;
    }
    A& operator=(A&& other){
        std::cout << "move assignment, old " << x
        << " other's " << other.x;
        if(x != nullptr){
            delete x;
            x = nullptr;
        }
        x = other.x;
        if (other.x != nullptr){
            other.x = nullptr;
        }
        std::cout << " new " << x << std::endl;
        return *this;
    }
};
```

# Auto Keyword

The compiler infers the type at compile time.

```{cpp}
#include <iostream>
int main(){
    auto x = 5;
    int y = x;
    std::cout << x << " " << y << std::endl;
}
```

# Object Ownership

The model for resource management, e.g. heap memory, we use is called object ownership. This is where each object has something, usually another object, that is responsible for freeing the resource.

## Basic Functions

Firstly we'll create an object that owns some heap memory and will print out all the common functions that deal with ownership.

### Attributes

```{cpp, eval=FALSE}
struct A{
    int* x;
};
```

### Constructor and Destructor

We'll create the constructor and destructor similar as to what you would have done in **SENG1120**.

```{cpp, eval=FALSE}
// Default Constructor
A():x(nullptr){}

// Constructor
A(const int& _x) : x(new int(_x)){
    std::cout << "constructing A pointing to " << x << std::endl;
}

// Destructor
~A(){
    std::cout << "destructing A, which pointed to " << x << std::endl;
    if (x != nullptr){
        delete x;
        x = nullptr;
    }
}
```
```{cpp}
#include "A.hpp"
int main(){
    A a{1};
}
```

### Copy Constructor

For copy construction we will create a deep copy of the object. This means that we will follow any pointers and copy the objects they point to. We do this because there are no guarantees that the objects pointed to will not be deconstructed by something else.

We do not gain any ownership over anything relating to the parameter but we do now own the newly constructed integer.

```{cpp, eval=FALSE}
// Copy constructor
A(const A& other){
    std::cout << "copy constructor, old " << x
    << " other's " << other.x;
    x = new int(*other.x);
    std::cout << " new " << x << std::endl;
}
```
```{cpp}
#include "A.hpp"
int main(){
    A a{1};
    A b{a};
}
```


### Copy Assignment

Similar to copy construction, but if this object has ownership of something we must first clean that up.

```{cpp, eval=FALSE}
// Copy assignment
A& operator=(const A& other){
    std::cout << "copy assignment, old " << x
    << " other's " << other.x;
    if(x != nullptr){
        delete x;
        x = nullptr;
    }
    x = new int(*other.x);
    std::cout << " new " << x << std::endl;
    return *this;
}
```
```{cpp}
#include "A.hpp"
int main(){
    A a{1};
    A b{2};
    b = a;
}
```

### Move Constructor

For a move constructor the parameter that is passed has had its ownership yielded, so we can be sure that nothing else will use or free the passed in resources. This allows us to do a shallow copy of the pointed to values, this means that we can just copy the pointers.

```{cpp, eval=FALSE}
// Move constructor
A(A&& other){
    std::cout << "move constructor, old " << x
    << " other's " << other.x;
    x = other.x;
    if (other.x != nullptr){
        other.x = nullptr;
    }
    std::cout << " new " << x << std::endl;
}
```
```{cpp}
#include <utility>
#include "A.hpp"
int main(){
    A a{1};
    A b(std::move(a));
}
```


### Move Assignment

Similar to move construction, but if this object has ownership of something we must first clean that up.

```{cpp, eval=FALSE}
// Move assignment
A& operator=(A&& other){
    std::cout << "move assignment, old " << x
    << " other's " << other.x;
    if(x != nullptr){
        delete x;
        x = nullptr;
    }
    x = other.x;
    if (other.x != nullptr){
        other.x = nullptr;
    }
    std::cout << " new " << x << std::endl;
    return *this;
}
```
```{cpp}
#include <utility>
#include "A.hpp"
int main(){
    A a{1};
    A b{};
    b = std::move(a);
}
```

## Smart Pointers

To manage memory and ownership we use smart pointers, these will delete our objects for us with some caveats.

### Unique

A unique pointer will manage an object on the heap, deleting it when the pointer goes out of scope.

Always use `std::make_unique` as this solves some problems, never use `new`.

```{cpp}
#include <memory>
#include "A.hpp"
int main(){
    std::unique_ptr<A> a = std::make_unique<A>(5);
    {
    // Make a scope so we can see this object get deleted before the one below gets constructed.
    std::unique_ptr<A> b = std::make_unique<A>(5);
    }
    std::unique_ptr<A> c = std::make_unique<A>(5);
}
```
We cannot copy a unique pointer, we can only move it. This prevents two separate objects owning the object that is pointed to.

```{cpp}
#include <memory>
#include "A.hpp"
int main(){
    std::unique_ptr<A> a = std::make_unique<A>(5);
    std::unique_ptr<A> b = a;
}
```
```{cpp}
#include <memory>
#include <utility>
#include "A.hpp"
int main(){
    std::unique_ptr<A> a = std::make_unique<A>(5);
    std::unique_ptr<A> b = std::move(a);
}
```


### Shared

### Weak

# Standard Library Features

# C++ Feautres
